# Мини-проект "Аквариум"

Привет! Этот урок рассчитан на повторение материала и закрепление материала. <br>

В чём суть проекта? Нужно сделать что-то наподобие аквариума с рыбками.<br>
### Давай начинать<br>
Что мы знаем про рыб? Мы точно знаем, что в аквариуме они передвигаются хаотично, без особой системы. Просто плавают туда-сюда. <br>
<br>
<img src="https://media1.tenor.com/m/jTs8imWCZuwAAAAd/3d-gifs-artist-clownfish.gif">
<br>
Это путь к пониманию и видению нашего проекта. Нам нужно будет воссоздать аквариум и сделать хаотичное движение рыбам. <br>
> [!IMPORTANT]
> Важно этот проект делать по частям и вдумчиво, чтобы лучше вникнуть в детали.

## Создание проекта
Начнем мы с создания самого проекта в `Godot Engine`. 
> Если нет Godot Engine на компьютере, то скачать можно [отсюда](https://godotengine.org/download/windows/) или в Steam.<br>

Как открыли движок - нужно нажать на кнопку `Новый проект`<br>
<br>
<img src="https://github.com/mykweenn/byteschool/blob/main/other/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-02-04%20163951.png">
<br>
После этого необходимо дать имя файлу, выбрать папку (по желанию) и создать папку. После этого нажать кнопку `Создать и редактировать`<br>
<br>
<img src="https://github.com/mykweenn/byteschool/blob/main/other/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-02-04%20164216.png">

## Настройка проекта
Внутри самого проекта мы будем наблюдать следующее:
<img src="https://github.com/mykweenn/byteschool/blob/main/other/img/image.png">

Для дальнейшей настройки нужно выбрать сразу же параметры окна. <br>
Заходим в левом верхнем углу `Проект` -> `Настройки проекта` -> `Основное` -> `Дисплей` -> `Окно` <br>
И проставляем следующие настройки:
<br>
![image](https://github.com/mykweenn/byteschool/assets/98867083/8170f551-fc29-47bb-9498-79d7608416ba)
<br>
![image](https://github.com/mykweenn/byteschool/assets/98867083/3feaff25-ff62-4163-89d1-bef065ca4a24)
<br>
> [!TIP]
> Настройка `Default Texture Filter` необходима для выбора алгоритма отрисовки текстур (делает пиксели заметнее)<br>


Убеждаемся, что настройки совпадают и продолжаем работу. <br>
Игра у нас будет двухмерная (2D) и поэтому создать нужно будет 2D сцену <br>
![image](https://github.com/mykweenn/byteschool/assets/98867083/035d40da-94af-411a-9c74-2386b0f048c6)
<br>
Сразу же сохраним созданную сцену сочетанием клавиш `CTRL + S` и начнем загрузку [файлов](https://github.com/mykweenn/byteschool/tree/main/other/res/sprites) необходимых для проекта
> [!IMPORTANT]
> Вот прям точно надо скачать одну из текстур рыбы и фон по ссылке выше. Фон называется `underwater-fantasy-preview.png`. А рыбу любую и сколько угодно, например можешь взять рыбку `1.png`.
<br>
Чтобы скачать файл нужно открыть его и нажать на кнопку скачивания в правом верхнем углу <br>

![image](https://github.com/mykweenn/byteschool/assets/98867083/49b13b25-2d44-494f-b3ad-58136eb45bb0)

Перетаскиваем фон на сцену и настраиваем эту картинку.

![image](https://github.com/mykweenn/byteschool/assets/98867083/648301d9-3095-4e60-aa58-22e639269993)

Сохраняем сцену.<br>

## Создание сцены с рыбой
Создать сцену можно несколькими способами:
- Через плюсик вверху
- `Сцена` -> `Новая сцена`
![image](https://github.com/mykweenn/byteschool/assets/98867083/e5fe7ce4-544e-46c8-a62c-31c46e9ddec7)

Далее, как создали сцену, необходимо выбрать узел.<br>
Жмем `Другой узел` и пишем в поисковике `CharacterBody2D`<br>
> Можно писать не полностью, здесь умный поисковик

Далее подключаем дочерние узлы к `CharacterBody2D`
> Жми ПКМ (правая кнопка мыши) на родительский узел `CharacterBody2D` и дальше кнопку `Добавить дочерний узел`. Подключи узлы, которые ты можешь увидеть на скрине.


Итог сцены с рыбой:<br>
![image](https://github.com/mykweenn/byteschool/assets/98867083/b8710cd0-eee7-4d0a-825b-4b78d062047d)

Узел `CharacterBody2D` лучше переименовать в `fish` (если у тебя много рыб, то через нижнее подчеркивание дай им уникальное имя, типа `fish_clown` или `fish_dory`)<br>

В узел `AnimatedSprite2D` нужно добавить саму картинку рыбы.<br>
1. У `AnimatedSprite2D` выбираем параметр `Animation` далее `Sprite Frames` и создаем новый `Sprite Frames`.
![image](https://github.com/mykweenn/byteschool/assets/98867083/d713c025-f53c-48e4-900d-8713e9c68cd0)<br>
![image](https://github.com/mykweenn/byteschool/assets/98867083/e1d7a058-c2c7-4f47-95e3-c01330dff027)<br>
2. Далее у нас открывается эта панель. Нужно переименовать анимацию `default` на что-то другое. Можно дать имя рыбе.
![image](https://github.com/mykweenn/byteschool/assets/98867083/18407687-171a-4a63-a5e8-ec1c5167a30b)<br>
3. Выбрать эту кнопку, для того, чтобы вырезать нужный кадр с рыбкой
![image](https://github.com/mykweenn/byteschool/assets/98867083/47b0be41-166c-4003-b5e0-6f8436103eae)<br>
4. Откроется это окно.
![image](https://github.com/mykweenn/byteschool/assets/98867083/d64708ef-e0b9-4cf6-8776-16c011eed829)
Нам нужно выставить значение у `Горизонтально` и `Вертикально` так, чтобы в одной клетке была одна рыбка.
![image](https://github.com/mykweenn/byteschool/assets/98867083/ae81018a-d2f6-496e-bc8a-c7e0349b1c48)<br>
Выбираем обе и жмем `Добавить кадров: 2`
![image](https://github.com/mykweenn/byteschool/assets/98867083/340ac887-c1e8-41e4-8b06-ea2395dcea23)<br>
Жмем кнопочку play для запуска анимации
![image](https://github.com/mykweenn/byteschool/assets/98867083/bc0c7298-35b9-49cc-88fe-d4d5584f772b)<br>
В узле `CollisionShape2D` нужно добавить фигуру коллизии.
![image](https://github.com/mykweenn/byteschool/assets/98867083/67f770a5-817c-4743-985f-b805fb3367ed)<br>
Лучше выбирать `CapsuleShape2D` и развернуть ее через `Transform` -> `Rotation`
![image](https://github.com/mykweenn/byteschool/assets/98867083/68e51444-a653-4dbd-b5aa-d08a5a153aa2)<br>
Поставим 90 градусов и немного можно будет уменьшить коллизию рыбы
![image](https://github.com/mykweenn/byteschool/assets/98867083/16325731-7655-4105-85fe-5926ce70b053)<br>
![image](https://github.com/mykweenn/byteschool/assets/98867083/2425158d-41cf-4fbe-b35d-cdd613e61ae0)<br>





Прикрепляем скрипт и сохраняем сцену<br>
>[!Tip]
>`CTRL + S` для сохранения

### Создание скрипта

>[!NOTE]
>С полным скриптом можно ознакомиться по этой [ссылке](https://gist.github.com/mykweenn/806f2841e97176408cedde04356cf06f)

В скрипте нам понадобятся следующие переменные:
``` gdscript
var screen_size 
var time_to_change_dir = 6
var timer = 0
var point = Vector2()
```
>[!Tip]
>Иногда можно понять смысл переменных или функций, если просто дословно их перевести!

Разберем для чего они вообще нужны? Отлично, погнали
- `var screen_size` - эта переменная будет у нас хранить в себе размер экрана
- `var time_to_change_dir = 6` - хранит в себе время для смены направления движения рыбки, время равняется 6
- `var timer = 0` - это просто таймер
- `var point = Vector2()` - это точка, до которой нужно будет дойти рыбе, эта точка генерируется случайно двумя векторами: X и Y

<br>

<br>
Первое с чего мы начнем - получение размеров `viewport` для настройки размеров экрана. Таким образом, если ты захочешь поменять размер окна в настройках - рыбка будет получать величину твоего экрана, какую бы ты ни поставил. И все благодаря методу `get_viewport_rect()` и параметру `size`.


``` gdscript
func _ready():
	screen_size = get_viewport_rect().size
```
**Давай разберем этот код построчно:**

Представим, что наша рыба, хочет узнать размер экрана, на котором она находится. Для этого мы используем функцию _ready(), которая вызывается один раз в начале игры, когда все объекты уже готовы к работе.<br>
В первой строке кода `screen_size = get_viewport_rect().size` мы говорим игре получить размер области экрана, на которой отображается игровой мир. Это поможет персонажу понять, сколько места у него есть для движения и действий.

**Далее мы напишем функцию для того, чтобы рыба могла начать шевелиться.<br>**


``` gdscript
func _process(delta):
	timer += delta
	time_to_change_dir = randi_range(2, 8)
	print(time_to_change_dir)
```
 **Давай разберем этот код построчно:**

1. `func _process(delta):` - Эта строка обозначает начало определения функции _process, которая автоматически вызывается каждый кадр игры (по умолчанию 60 раз в секунду). `delta` - это параметр, который представляет собой время, прошедшее с момента последнего кадра.

2. `timer += delta` - Эта строка увеличивает значение переменной timer на количество прошедшего времени с предыдущего кадра. Это обычно используется для отслеживания времени в игре.

3. `time_to_change_dir = randi_range(2, 8)` - Здесь мы создаем переменную `time_to_change_dir` и присваиваем ей случайное целое число в диапазоне от 2 до 8. Функция `randi_range(a, b)` генерирует случайное целое число включительно от a до b.

4. `print(time_to_change_dir)` - Этот код выводит значение переменной time_to_change_dir в консоль (терминал), чтобы мы могли видеть, какое случайное число было сгенерировано.

>[!Tip]
>Ты можешь открыть код по ссылке выше и сверяться оттуда
<br>

``` gdscript
	if timer >= time_to_change_dir:
		timer = 0
		point = Vector2(randf_range(0,screen_size.x), randf_range(0, screen_size.y))
	self.position = lerp(self.position, point, 0.002)
```
 **Давай разберем этот код построчно:**
1. `if timer >= time_to_change_dir:` - Эта строка представляет условный оператор if, который проверяет, если значение переменной timer больше или равно значению переменной `time_to_change_dir`.

2. `timer = 0` - Если условие в предыдущей строке выполняется (значение `timer` больше или равно `time_to_change_dir`), то переменная timer устанавливается обратно в 0. Это означает, что прошло достаточно времени для изменения направления.

3. `point = Vector2(randf_range(0, screen_size.x), randf_range(0, screen_size.y))` - Здесь мы создаем переменную point и присваиваем ей новый объект типа Vector2, который представляет собой случайные координаты в пределах экрана игры. Функция randf_range(a, b) генерирует случайное число с плавающей запятой в диапазоне от a до b.
4. `self.position = lerp(self.position, point, 0.002)` - Этот код использует функцию lerp (linear interpolation) для плавного перемещения объекта к новой точке point. 
  - `lerp(self.position, point, 0.002)` - Функция `lerp` принимает три параметра: начальную точку `(self.position)`, конечную точку `(point)` и фактор скорости перемещения (в данном случае 0.002). Она вычисляет промежуточную точку между начальной и конечной точками, чтобы объект двигался плавно к новой цели.
  - `self.position = lerp(...)` - Результат выполнения функции lerp присваивается обратно переменной `self.position`, что обновляет позицию объекта на экране.

Таким образом, эта строка кода обеспечивает плавное перемещение объекта к случайной точке point с постепенным приближением к этой цели.

<br>
Дальше мы разберем подробнее используемую формулу линейной интерполяции, вдруг если не совсем понятно как и зачем это нужно.<br>
Прости, но дальше будет чуточку душно.<br>
<br>

**Формула линейной интерполяции:**
``` math
    interp = (1 - t) ·start + t ·end
```

где:
- interp - результат интерполяции,
- t - коэффициент интерполяции в диапазоне [0, 1],
- start - начальное значение,
- end - конечное значение.

**Формула метода lerp() из Godot Engine:**
```
    lerp(start, end, t)
```

где:
- start - начальное значение,
- end - конечное значение,
- t - коэффициент интерполяции в диапазоне [0, 1].
<br>
Отличие между формулой линейной интерполяции и методом `lerp()` заключается в том, что метод `lerp()` является более удобным и компактным способом для выполнения линейной интерполяции в Godot Engine. Метод `lerp()` принимает начальное и конечное значения, а также коэффициент интерполяции t и возвращает результат интерполяции.<br>

<br>
<details>
<summary>Еще подробнее можно почитать здесь</summary>
<br>
Коэффициент интерполяции (t) играет ключевую роль в процессе линейной интерполяции. Он определяет, насколько близко мы находимся к конечному значению в результате интерполяции. Вот несколько причин, по которым коэффициент интерполяции важен:

1. Плавные анимации: Коэффициент интерполяции позволяет создавать плавные анимации и переходы между значениями. При изменении t от 0 до 1 значение результата изменяется плавно от начального к конечному.

2. Контроль скорости: Изменяя значение t, можно контролировать скорость изменения значения в процессе интерполяции. Например, при t = 0.5 изменение будет происходить на полпути между начальным и конечным значениями.

3. Адаптивность: Используя коэффициент интерполяции, можно легко адаптировать интерполяцию для различных задач и эффектов, варьируя скорость и стиль перехода между значениями.

4. Универсальность: Коэффициент интерполяции позволяет использовать одну и ту же формулу для интерполяции различных типов данных и значений, делая ее универсальной и применимой в различных ситуациях.

Таким образом, коэффициент интерполяции является важным параметром, который дает контроль над процессом линейной интерполяции и позволяет создавать плавные и адаптивные эффекты в анимациях, играх и других приложениях.<br>
<br>
>Линейная интерполяция широко используется в компьютерной графике, анимации, компьютерных играх, а также в обработке сигналов и цифровой обработке изображений. Например, при перемещении объекта от одной точки к другой на экране, линейная интерполяция может использоваться для плавного и равномерного изменения координат объекта по времени. Также линейная интерполяция может применяться для заполнения промежутков между известными значениями данных.
</details>

Следующий код направлен на настройку анимации рыбы.<br>
<br>
У узла `AnimatedSprite2D` можно настроить отражение по горизонтали таким образом:
![Flip-H](https://github.com/mykweenn/byteschool/assets/98867083/e0ac03ba-138d-4379-b4ae-79775b66aaec)<br>


``` gdscript
	if point.x > self.position.x:
		$AnimatedSprite2D.flip_h = false;
	else: 
		$AnimatedSprite2D.flip_h = true;
```
Этот код проверяет, находится ли точка с координатой x правее (больше) позиции объекта, в котором этот код выполняется. Если это так, то изображение, которое отображается на объекте (обозначенном как`$AnimatedSprite2D`), не будет отражено по горизонтали `(flip_h = false)`. Если точка находится слева (меньше или равна) позиции объекта, изображение будет отражено по горизонтали `(flip_h = true)`. Таким образом, объект будет "смотреть" в сторону точки, находящейся дальше по оси x.

Если точка, куда нам нужно идти, находится правее нашего персонажа, то мы должны повернуть персонажа вправо, чтобы он шел в сторону этой точки. А если точка находится левее нашего персонажа, то мы должны повернуть его влево, чтобы он двигался к этой точке.<br>
<br>
И последние строчки кода:
``` gdscript
	position = position.clamp(Vector2.ZERO, screen_size)
	move_and_slide()
```
1. `position = position.clamp(Vector2.ZERO, screen_size):` Эта строка кода означает, что позиция объекта ограничивается в пределах определенной области. Метод `clamp` используется для этого. В данном случае, `Vector2.ZERO` представляет точку (0, 0), а `screen_size` - размер экрана игры. Таким образом, позиция объекта будет ограничена в пределах от (0, 0) до размеров экрана.

2. `move_and_slide():` Этот метод вызывается для перемещения объекта с учетом столкновений с другими объектами и физическими законами. Он автоматически обрабатывает столкновения и скольжение объекта по поверхности.

И после всех проделанных манипуляций с кодом, рыбка готова! Можно добавлять на главную сцену.
Можно несколькими способами:
- Нажать на главную сцену, нажать на `Node2D` ПКМ и нажать на кнопку `Добавить дочернюю сцену` и выбрать нашу рыбу
- Или из файловой системы (слева снизу, там еще много файлов проекта) просто перетащить на сцену

>[!IMPORTANT]
>Когда будешь запускать игру и проверять ее, выскочет окошко и нужно будет нажать `Выбрать текущий`
>![image](https://github.com/mykweenn/byteschool/assets/98867083/c4d79ec1-f58c-4bbe-90bd-ade3eb265641)

## Добавим красоты
Чтобы добавить такую небольшую пелену синего цвета<br>
![image](https://github.com/mykweenn/byteschool/assets/98867083/2b692c31-59da-454d-9079-f4cd4ed9a08d)
<br>
Необходимо добавить дочерний узел ColorRect и справа в параметре `Color` настроить цвет (выберешь самостоятельно)
![image](https://github.com/mykweenn/byteschool/assets/98867083/4752cda7-2b6b-4665-ae63-e65b8a34f3c2)
И настроить его по ширине экрана (или он еще называется viewport)
![image](https://github.com/mykweenn/byteschool/assets/98867083/1cea899d-32b2-44df-be80-28e931ddb89e)
>Давай представим, что ты играешь в игру на компьютере. Экран, на котором отображается игровой мир, называется `viewport`. Когда ты играешь в игру, `viewport` показывает тебе только часть игрового мира, которая помещается на экране.<br>В игровом движке `Godot Engine` `viewport` - это специальная область, которая отображает часть игрового мира на экране. `Viewport` определяет, какие объекты и эффекты должны быть видны на экране в данный момент. Например, если ты играешь в платформер, `viewport` будет показывать тебе только ту часть уровня, где находится твой персонаж.<br>`Viewport` в `Godot Engine` также позволяет создавать различные эффекты, такие как масштабирование, поворот и перемещение игрового мира на экране. Он помогает разработчикам создавать интересные и динамичные игровые сцены, которые можно увидеть на экране компьютера или мобильного устройства.<br>
Фиолетовая рамка в редакторе - это `viewport`
![image](https://github.com/mykweenn/byteschool/assets/98867083/985285ac-f18d-4a2d-9dbc-3e618bbf8ca2)<br>

>[!IMPORTANT]
>Убедись, что у тебя узлы выглядят примерно так! На заднем плане те узлы, которые выше по списку, а на переднем плане, которые ниже в списке узлов. И смотри, чтобы они не прикрепились друг к другу.<br>

![image](https://github.com/mykweenn/byteschool/assets/98867083/1d961635-e9e0-47e5-9079-f061d34e7792)

Ну вот и все. Попробуй запустить игру и проверить. Можешь расставить побольше рыб и посмотреть что вышло.
